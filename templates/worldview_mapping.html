{% extends "base.html" %}
{% block content %}
<h2>Worldview Mapping</h2>
<div id="map" style="height: 600px; width:100%;"></div>

<!-- Timeline slider -->
<div class="my-3" style="width:100%; max-width:1100px; margin:auto;">
  <label for="timeline" style="font-weight:bold;">
    Year: <span id="selected-year"></span>
  </label>
  <input
    type="range"
    id="timeline"
    min="0"
    max="{{ years|length - 1 }}"
    value="0"
    style="width:100%; display:block; margin-bottom:0.5em;"
  >
  <div id="year-labels" style="display:flex; justify-content:space-between; font-size:0.7em; margin-top:-0.5em;">
    {% for y in years %}
      <span style="display:inline-block; transform: rotate(-90deg); white-space:nowrap; font-size:0.75em;">{{ y }}</span>
    {% endfor %}
  </div>
</div>

<div id="historic-context" class="alert alert-info"></div>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
// data injected from Flask
const letterData = {{ letter_data|tojson }};
const years = {{ years|tojson }};
const yearContext = {{ year_context|tojson }};

// DEBUG: Check if Washington D.C. data is present - ADD THESE LINES
console.log("=== DEBUGGING WASHINGTON D.C. ===");
console.log("Total letters:", letterData.length);
const dcLetters = letterData.filter(l => l.sent_from && l.sent_from.name === "Washington D.C.");
console.log("Letters from Washington D.C.:", dcLetters.length);
if (dcLetters.length > 0) {
  console.log("First DC letter full object:", dcLetters[0]);
  console.log("DC letter years:", dcLetters.map(l => l.year));
}
console.log("Available years in slider:", years);
console.log("=== END DEBUG ===");

// basic historic-context renderer (expects "Home","South Carolina","National","International" keys)
function renderYearContext(year) {
  const ctx = yearContext[year];
  if (!ctx) return "No historic context for this year.";
  if (Array.isArray(ctx)) return ctx.join('<br>');
  if (typeof ctx === 'string') return ctx;
  const sections = ["Home", "South Carolina", "National", "International"];
  let html = '';
  sections.forEach(sec => {
    const items = ctx[sec];
    if (items && (Array.isArray(items) ? items.length : String(items).trim().length)) {
      html += `<h5 style="margin-top:8px;margin-bottom:4px;">${sec}</h5>`;
      if (Array.isArray(items)) {
        html += '<ul style="margin-top:0;margin-bottom:6px;padding-left:18px;">' +
                items.map(i => `<li>${i}</li>`).join('') +
                '</ul>';
      } else {
        html += `<div style="margin-bottom:6px;">${items}</div>`;
      }
    }
  });
  return html || "No historic context for this year.";
}

// Leaflet map init - centered on USA with appropriate zoom
const map = L.map('map').setView([37.8, -96], 4);

// Use Esri World Street Map tiles with blue water
L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
  maxZoom: 19,
  attribution: 'Tiles &copy; Esri'
}).addTo(map);

let markers = [];
const markersByLeafletId = {}; // leaflet id -> marker

// Build an index of unique locations (by lat,lon) and collect mentions
function buildLocationIndex(letters) {
  const idx = {};
  letters.forEach(letter => {
    // sent_from and sent_to
    [['sent_from','blue-dot'], ['sent_to','red-dot']].forEach(([key, icon]) => {
      const loc = letter[key];
      if (loc && loc.lat && loc.lon) {
        const k = `${loc.lat},${loc.lon}`;
        if (!idx[k]) {
          idx[k] = { name: loc.name, lat: loc.lat, lon: loc.lon, mentions: [], defaultIcon: icon };
        } else {
          // If entry exists and current icon is blue/red, upgrade from green
          if (icon !== 'green-circle') {
            idx[k].defaultIcon = icon;
          }
        }
        idx[k].mentions.push({
          letter_number: letter.letter_number,
          date: letter.date,
          file: `/static/BFPerryLettersSeparated/BFPerry_Letter${letter.letter_number}.txt`
        });
      }
    });
    // mentioned locations
    (letter.mentioned || []).forEach(loc => {
      if (loc && loc.lat && loc.lon) {
        const k = `${loc.lat},${loc.lon}`;
        if (!idx[k]) {
          idx[k] = { name: loc.name, lat: loc.lat, lon: loc.lon, mentions: [], defaultIcon: 'green-circle' };
        }
        // Don't downgrade blue/red markers to green - only add the mention
        idx[k].mentions.push({
          letter_number: letter.letter_number,
          date: letter.date,
          file: `/static/BFPerryLettersSeparated/BFPerry_Letter${letter.letter_number}.txt`
        });
      }
    });
  });
  console.log("Location index:", idx);
  return idx;
}

// Calculate opacity based on number of mentions
function getOpacity(mentionCount) {
  // Map mention count to opacity
  // 1 mention = 0.3 opacity, more mentions = up to 1.0 opacity
  const maxMentions = 15; // adjust this threshold as needed
  const minOpacity = 0.3;
  const maxOpacity = 1.0;
  const normalized = Math.min(mentionCount / maxMentions, 1);
  return minOpacity + (normalized * (maxOpacity - minOpacity));
}

// Popup HTML for a location entry at mention index i
function makePopupHtml(locEntry, i) {
  const m = locEntry.mentions[i];
  const total = locEntry.mentions.length;
  const prevDisabled = i === 0 ? 'disabled' : '';
  const nextDisabled = i === total - 1 ? 'disabled' : '';
  
  // Determine the relationship text based on marker type
  let relationshipText = '';
  if (locEntry.defaultIcon === 'blue-dot') {
    relationshipText = `${total} letter${total > 1 ? 's' : ''} sent from this location`;
  } else if (locEntry.defaultIcon === 'red-dot') {
    relationshipText = `${total} letter${total > 1 ? 's' : ''} sent to this location`;
  } else {
    relationshipText = `${total} letter${total > 1 ? 's' : ''} mention this location`;
  }
  
  return `
    <div>
      <strong>${locEntry.name || 'Unknown'}</strong><br/>
      <span style="font-size:0.9em; color:#666;">${relationshipText}</span><br/>
      <a href="${m.file}" target="_blank">View Letter ${m.letter_number}</a><br/>
      <small>${m.date || ''}</small>
      <div style="margin-top:6px; text-align:center;">
        <button onclick="cycleMention(this, -1)" data-marker-id="${locEntry._leafletId}" data-index="${i}" ${prevDisabled}>&laquo; Prev</button>
        <span style="margin:0 8px">${i + 1} / ${total}</span>
        <button onclick="cycleMention(this, 1)" data-marker-id="${locEntry._leafletId}" data-index="${i}" ${nextDisabled}>Next &raquo;</button>
      </div>
    </div>
  `;
}

// global function to cycle mentions (called from popup buttons)
function cycleMention(btn, delta) {
  const markerId = btn.getAttribute('data-marker-id');
  const currentIndex = parseInt(btn.getAttribute('data-index'), 10);
  const marker = markersByLeafletId[markerId];
  if (!marker) return;
  const locEntry = marker._locEntry;
  let newIndex = currentIndex + delta;
  if (newIndex < 0) newIndex = 0;
  if (newIndex >= locEntry.mentions.length) newIndex = locEntry.mentions.length - 1;
  const newHtml = makePopupHtml(locEntry, newIndex);
  marker.setPopupContent(newHtml);
  marker.openPopup();
}

// add aggregated markers to map for given letters
function addAggregatedMarkers(lettersToShow) {
  console.log(`Adding markers for ${lettersToShow.length} letters`);
  markers.forEach(m => map.removeLayer(m));
  markers = [];
  Object.keys(markersByLeafletId).forEach(k => delete markersByLeafletId[k]);

  const index = buildLocationIndex(lettersToShow);
  const bounds = [];

  Object.values(index).forEach(locEntry => {
    console.log(`Creating marker for ${locEntry.name} at ${locEntry.lat}, ${locEntry.lon}`);
    let marker;
    if (locEntry.defaultIcon === 'green-circle') {
      // Mentioned location - use varying opacity based on mention count
      const mentionCount = locEntry.mentions.length;
      const opacity = getOpacity(mentionCount);
      marker = L.circleMarker([locEntry.lat, locEntry.lon], { 
        radius: 7, 
        color: 'darkgreen',        // Dark outline
        fillColor: 'green',        // Original green fill
        fillOpacity: opacity,      // Variable opacity based on mentions
        weight: 2
      });
    } else {
      const iconUrl = locEntry.defaultIcon === 'blue-dot'
        ? 'https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png'
        : 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png';
      marker = L.marker([locEntry.lat, locEntry.lon], { icon: L.icon({ iconUrl, iconSize: [32,32], iconAnchor: [16,32] }) });
    }

    marker._locEntry = locEntry;
    marker.addTo(map);
    locEntry._leafletId = marker._leaflet_id;
    markersByLeafletId[String(marker._leaflet_id)] = marker;

    const popupHtml = makePopupHtml(locEntry, 0);
    marker.bindPopup(popupHtml);

    markers.push(marker);
    bounds.push([locEntry.lat, locEntry.lon]);
  });

  // Fit bounds to show all markers
  if (bounds.length > 0) map.fitBounds(bounds, { padding: [30,30] });
  console.log(`Created ${markers.length} markers`);
}

// updateMap chooses letters for the selected year (or All)
function updateMap(year) {
  console.log(`Updating map for year: ${year}`);
  const lettersToShow = (year === "All") ? letterData : letterData.filter(l => l.year === year);
  console.log(`Filtered to ${lettersToShow.length} letters`);
  addAggregatedMarkers(lettersToShow);
}

// timeline and historic context wiring
const timeline = document.getElementById('timeline');
const selectedYear = document.getElementById('selected-year');
const historicContext = document.getElementById('historic-context');

function updateYearDisplay(idx) {
  const year = years[idx];
  selectedYear.textContent = year;
  historicContext.innerHTML = renderYearContext(year);
  updateMap(year);
}

// set up slider events and initialize
timeline.addEventListener('input', function() { updateYearDisplay(this.value); });

// set initial labels and init map display
if (years.length > 0) {
  timeline.max = years.length - 1;
  updateYearDisplay(0);
} else {
  selectedYear.textContent = '';
  historicContext.textContent = "No years available.";
}
</script>
{% endblock %}