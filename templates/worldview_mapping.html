{% extends "base.html" %}
{% block content %}
<h2>Worldview Mapping</h2>
<div id="map" style="height: 600px;"></div>

<!-- Timeline slider -->
<div class="my-3" style="width:100%; max-width:900px; margin:auto;">
  <label for="timeline" style="font-weight:bold;">
    Year: <span id="selected-year"></span>
  </label>
  <input
    type="range"
    id="timeline"
    min="0"
    max="{{ years|length - 1 }}"
    value="0"
    style="width:100%; display:block; margin-bottom:0.5em;"
  >
  <div id="year-labels" style="display:flex; justify-content:space-between; font-size:0.7em; margin-top:-0.5em;">
    {% for y in years %}
      <span style="display:inline-block; transform: rotate(-90deg); white-space:nowrap; font-size:0.8em;">{{ y }}</span>
    {% endfor %}
  </div>
</div>

<!-- Historic context -->
<div id="historic-context" class="alert alert-info"></div>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const letterData = {{ letter_data|tojson }};
const years = {{ years|tojson }};
const yearContext = {{ year_context|tojson }};

const map = L.map('map').setView([34, -82], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);

let markers = [];
const markersByLeafletId = {}; // map leaflet id -> marker (for popup cycling)

// Build aggregated location index so a single marker represents all mentions at same coords
function buildLocationIndex(letters) {
  const index = {}; // key -> { name, lat, lon, mentions: [ {letter_number, date, file} ] }
  letters.forEach(letter => {
    // handle sent_from and sent_to as single-mention locations (optional)
    [['sent_from', 'blue-dot'], ['sent_to', 'red-dot']].forEach(([key, icon]) => {
      const loc = letter[key];
      if (loc && loc.lat && loc.lon) {
        const k = `${loc.lat},${loc.lon}`;
        index[k] = index[k] || { name: loc.name, lat: loc.lat, lon: loc.lon, mentions: [] , defaultIcon: icon};
        index[k].mentions.push({
          letter_number: letter.letter_number,
          date: letter.date,
          file: `/static/BFPerryLettersSeparated/BFPerry_Letter${letter.letter_number}.txt`
        });
      }
    });

    // mentioned locations (can be many per letter)
    letter.mentioned.forEach(loc => {
      if (loc && loc.lat && loc.lon) {
        const k = `${loc.lat},${loc.lon}`;
        index[k] = index[k] || { name: loc.name, lat: loc.lat, lon: loc.lon, mentions: [], defaultIcon: 'green-circle' };
        index[k].mentions.push({
          letter_number: letter.letter_number,
          date: letter.date,
          file: `/static/BFPerryLettersSeparated/BFPerry_Letter${letter.letter_number}.txt`
        });
      }
    });
  });
  return index;
}

function makePopupHtml(locEntry, idx) {
  const m = locEntry.mentions[idx];
  const total = locEntry.mentions.length;
  const prevDisabled = idx === 0 ? 'disabled' : '';
  const nextDisabled = idx === total - 1 ? 'disabled' : '';
  // show link to letter text and basic info; Prev/Next buttons to cycle mentions
  return `
    <div>
      <strong>${locEntry.name}</strong><br/>
      <a href="${m.file}" target="_blank">View Letter ${m.letter_number}</a><br/>
      <small>${m.date || ''}</small>
      <div style="margin-top:6px; text-align:center;">
        <button onclick="cycleMention(this, -1)" data-marker-id="${locEntry._leafletId}" data-index="${idx}" ${prevDisabled}>&laquo; Prev</button>
        <span style="margin:0 8px">${idx + 1} / ${total}</span>
        <button onclick="cycleMention(this, 1)" data-marker-id="${locEntry._leafletId}" data-index="${idx}" ${nextDisabled}>Next &raquo;</button>
      </div>
    </div>
  `;
}

// global function called by buttons inside popup; element is the clicked button
function cycleMention(btn, delta) {
  const markerId = btn.getAttribute('data-marker-id');
  const currentIndex = parseInt(btn.getAttribute('data-index'), 10);
  const marker = markersByLeafletId[markerId];
  if (!marker) return;
  const locEntry = marker._locEntry;
  let newIndex = currentIndex + delta;
  if (newIndex < 0) newIndex = 0;
  if (newIndex >= locEntry.mentions.length) newIndex = locEntry.mentions.length - 1;
  // update popup content and data-index attributes
  const newHtml = makePopupHtml(locEntry, newIndex);
  marker.setPopupContent(newHtml);
  // reopen to ensure updated content (Leaflet keeps popup open)
  marker.openPopup();
}

function addAggregatedMarkers(lettersToShow) {
  // remove old
  markers.forEach(m => map.removeLayer(m));
  markers = [];
  Object.keys(markersByLeafletId).forEach(k => delete markersByLeafletId[k]);

  const locIndex = buildLocationIndex(lettersToShow);
  const bounds = [];

  Object.values(locIndex).forEach(locEntry => {
    // create marker: use circleMarker for mentioned/default, special icons for sent_from/to if desired
    let marker;
    if (locEntry.defaultIcon === 'green-circle') {
      marker = L.circleMarker([locEntry.lat, locEntry.lon], { radius: 7, color: 'green' });
    } else {
      const iconUrl = locEntry.defaultIcon === 'blue-dot'
        ? 'https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png'
        : 'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png';
      marker = L.marker([locEntry.lat, locEntry.lon], { icon: L.icon({ iconUrl, iconSize: [32,32], iconAnchor: [16,32] }) });
    }

    // attach locEntry to marker for cycling
    marker._locEntry = locEntry;
    // add to map
    marker.addTo(map);
    // after adding, Leaflet assigns _leaflet_id
    locEntry._leafletId = marker._leaflet_id;
    markersByLeafletId[String(marker._leaflet_id)] = marker;

    // create initial popup (first mention)
    const popupHtml = makePopupHtml(locEntry, 0);
    marker.bindPopup(popupHtml);

    markers.push(marker);
    bounds.push([locEntry.lat, locEntry.lon]);
  });

  if (bounds.length > 0) {
    map.fitBounds(bounds, { padding: [30,30] });
  }
}

// updateMap chooses lettersToShow by year and calls addAggregatedMarkers
function updateMap(year) {
  const lettersToShow = (year === "All") ? letterData : letterData.filter(l => l.year === year);
  addAggregatedMarkers(lettersToShow);
}

// Timeline slider logic (unchanged)
const timeline = document.getElementById('timeline');
const selectedYear = document.getElementById('selected-year');
const historicContext = document.getElementById('historic-context');

function updateYearDisplay(idx) {
  const year = years[idx];
  selectedYear.textContent = year;
  if (Array.isArray(yearContext[year])) {
    historicContext.innerHTML = yearContext[year].join('<br>');
  } else if (yearContext[year]) {
    historicContext.textContent = yearContext[year];
  } else {
    historicContext.textContent = "No historic context for this year.";
  }
  updateMap(year);
}

// Initialize
timeline.addEventListener('input', function() {
  updateYearDisplay(this.value);
});
updateYearDisplay(0);
</script>
{% endblock %}